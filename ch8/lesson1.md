
## 具体的集合

Java类库集合，并简要描述了每个集合类的用途。除了以Map结尾的类之外，其他类都实现了Collection接口，
而以Map结尾的类实现了Map接口。

| 集合类型 | 描述 |
|----|----|
| ArrayList | 一种可以动态增长和缩减的索引序列 |
| LinkedList | 一种可以在任何位置进行高效的插入和删除操作的有序序列 |
| ArrayDeque | 一种用循环数组实现的双端队列 |
| HashSet | 一种没有重复元素的无序集合 |
| TreeSet | 一种有序集 |
| EnumSet | 一种包含枚举类型值的集 |
| LinkedHashSet | 一种以记住元素插入次序的集 |
| PriorityQueue | 一种允许高效删除最小元素的集合 |
| HashMap | 一种存储键\/值关联的数据结构 |
| TreeMap | 一种键值有序排列的映射表 |
| EnumMap | 一种键值属于枚举类型的映射表 |
| LinkedHashMap | 一种可以记住键\/值项添加次序的映射表 |
| WeakHashMap | 一种其值无用武之地后可以被垃圾回收器回收的映射表 |
| IdentityHashMap | 一种用==而不是用equals比较键值的映射表 |


### 链表

在本书中，有很多示例已经使用了数组以及动态的ArrayList类。然而，数组和数组列表都有一个重大的缺陷。
这就是从数组的中间位置删除一个元素要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素
都要想数组的前端移动。这数组中间的位置上插入一个元素也是如此。

另外一个大家非常熟悉的数据结构--链表（linked list）解决了这个问题。尽管数组在连续的存储位置
上存放对象引用，但链表却将每个对象存放在独立的结点中。每个结点还存放着序列中下一个结点的引用。
在Java程序设计语言中，所有链表实际上都是双向链接的（doubly linked），即每个结点还存放着
指向前驱结点的引用。

从链表中间删除一个元素是一个很轻松的操作，即需要更新被删除元素附近的链接。

你也许曾经在数据结构课程中学习过如何实现链表的操作。在链表中添加或删除元素时，绕来绕去的指针可能已经
给人们留下了极坏的印象。
下面的代码示例中，先添加3个元素，然后再将第2个元素删除
```
List<String> staff = new LinkedList<>();  // LinkedList implements List
staff.add("Amy");
staff.add("Bob");
staff.add("Carl");

Iterator iter = staff.iterator();
String first = iter.next(); // visit first element
String second = iter.next(); // visit second element
iter.remove(); // remove last visited element
```
但是，链表与泛型集合之间有一个重要的区别。链表是一个有序集合（ordered collection），每个对象的
位置十分重要。LinkedList.add方法将对象添加到链表的尾部。但是，常常需要将元素添加到链表的中间。
由于迭代器是描述集合中位置的，所以这种依赖位置的add方法将由迭代器负责。只有对自然有序的集合使用
迭代器添加元素才有实际意义。例如，下一节将要讨论的集（Set）类型，其中的元素完全无序。因此，在Iterator
接口中就没有add方法。相反地，集合类库提供了子接口ListIterator，其中包含add方法。
```
interface ListIterator<E> extends Iterator<E>
{
    void add(E element);
    ...
}
```
与Collection.add不同，这个方法不返回boolean类型的值，它假定添加操作总会改变链表。
另外，ListIterator接口有两个方法，可以用来反向遍历链表
```
E previous()
boolean hashPrevious()
```
与next方法一样，previous方法返回越过的对象。
LinkedList类的listIterator方法返回一个实现了ListIterator接口的迭代器对象。
```
ListIterator<String> iter = staff.listIterator();
```
Add方法在迭代器位置之前添加一个新对象。例如，下面的代码将越过链表中的第一个元素，并在第二个
元素之前添加"Juliet"
```
List<String> staff = new LinkedList<>();
staff.add("Amy");
staff.add("Bob");
staff.add("Carl");
ListIterator<String> iter = staff.listIterator();
iter.next(); // skip past first element
iter.add("Juliet");
```

如果多次调用add方法，将按照提供的次序把元素添加到链表中。它们被依次添加到迭代器当前位置之前。

当用一个刚刚由Iterator方法返回，并且指向链表表头的迭代器调用add操作时，新添加的元素将变成列表的新
表头。当迭代器越过链表的最后一个元素时（即hasNext返回false），添加的元素将变成列表的新表尾。
如果链表有n个元素，有n+1个位置可以添加新元素。这些位置与迭代器的n+1个可能的位置相对应。

add方法只依赖于迭代器的位置，而remove方依赖于迭代器的状态。

最后需要说明，set方法用一个新元素取代调用next或previous方法返回的上一个元素。例如，下面的代码将用
一个新值取代链表的第一个元素
```
ListIterator<String> iter = list.listIterator();
String  oldValue = iter.next();  // returns first element
iter.set(newValue); // sets first element to newValue
```
可以想象，如果在某个迭代器修改集合时，另一个迭代器对其进行遍历，一定会出现混乱的状况。

为了避免发生并发修改的异常，请遵循下述简单规则，可以根据需要给容器附加许多的迭代器，但是这些迭代器只能
读取列表。另外，再单独附加一个既能读又能写的迭代器。

对于并发修改列表的检测有一个奇怪的例外。链表只负责跟踪对列表的结构性修改，例如，添加元素、删除元素。
set方法不被视为结构性修改。可以将多个迭代器附加给一个链表，所有的迭代器都调用set方法对现有结点的
内容进行修改。

现在已经介绍了LinkedList类的各种基本方法。可以使用ListIterator类从前后两个方向遍历链表中的元素，
并可以添加、删除元素。

Collection接口声明了许多用于对链表操作的有用方法，其中大部分方法都是在LinkedList类的超类AbstractCollection
中实现的。例如，toString方法调用了所有元素的toString，并产生一个很长的格式为`[A, B, C]`的字符串。
这为调试工作提供了便利。可以使用contains方法检测某个元素是否出现在链表中。例如，如果链表中包含一个
等于"Harry"的字符串，调用staff.contains("Harry")后会返回true。

在Java类库中，还提供了许多在理论上存在一定争议的方法。链表不支持快速的随机访问。如果要查看链表中第n
个元素，就必须从头开始，越过n-1个元素。没有捷径可走。鉴于这个原因，在程序需要采用整数索引访问元素时，
程序员通常不选用链表。

尽管如此，LinkedList类还是提供了一个用来访问某个特定元素的get方法
```
LinkedList<String> list = ...;
String obj = list.get(n)
```
当然，这个方法的效率并不太高。如果发现自己正在使用这个方法，说明有可能对于所要解决的问题使用了错误的
数据结构。

绝对不应该使用这种让人误解的随机访问方法来遍历链表。下面这段代码的效率极低。
```
for (int i = 0; i < list.size(); i++)
    do something with list.get(i)
```
每次查找一个元素都要从列表的头部重新开始搜索。LinkedList对象根本不做任何缓存位置信息的操作。

我们建议避免使用以整数索引表示链表中位置的所有方法。如果需要对集合进行随机访问，就使用数组或ArrayList，
而不要使用链表。

### 数组列表

上一节中，介绍了List接口和实现了这个接口的LinkedList类。List接口用于描述一个有序集合，并且集合中
每个元素的位置十分重要。有两种访问元素的协议，一种是用迭代器，另一种是用get和set方法随机地访问每个元素。
后者不适用于链表，但对于数组却很有用。集合类库提供了一种大家熟悉的ArrayList类，这个类也实现了List接口。
ArrayList封装了一个动态再分配的对象数组。

对于一个经验丰富的Java程序员来说，在需要动态数组时，可能会使用Vector类。为什么要用ArrayList取代Vector呢？
原因很简单，Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象。但是，如果由一个线程访问
Vector，代码要在同步操作上耗费大量的时间。而ArrayList方法不是同步的，因此，建议在不需要同步时使用ArrayList。

### 散列集

链表和数组可以按照人们的意愿排列元素的次序。但是，如果想要看某个指定的元素，却又忘记了它的位置，就需要访问
所有的位置，直到找到为止。如果集合中包含的元素很多，将会消耗很多时间。如果不在意元素的顺序，可以有几种能够快速
查找元素的数据结构。其缺点是无法控制元素出现的次序。它们将按照有利于其操作目的的原则组织数据。

有一种众所周知的数据结构，可以快速地查找所需的对象，这就是散列表（hash table）。散列表为每个对象计算一个
整数，称为散列码（hash code）。散列码是由对象的实例域产生的一个整数。更准确地说，具有不同数据域的对象
将产生不同的散列码。

列出几个散列码的示例，它们是由String类的hashCode方法产生的

| 串 | 散列码 |
|----|----|
| "Lee" | 76268 |
| "lee" | 107020 |
| "eel" | 100300 |

如果自定类，就要负责实现这个类的hashCode方法。自己实现的hashCode方法应该与equals方法兼容，
即如果a.equals(b)为true，a与b必须具有相同的散列码。

现在，最重要的问题是散列码要能够快速地计算出来，并且这个计算只与要散列的对象状态有关，与散列表
中的其他对象无关。

在Java中，散列表用链表组实现。每个列表被称为桶（bucket）。要想查找表中对象的位置，就要先计算它的散列码，
然后与桶的总数取余，所得的结果就保存这个元素的桶的索引。

例如，如果某个对象的散列码为76268，并且有128个桶，对象应该保存在108号桶中（76268除以128余108）。
或许会很幸运，在这个桶中没有其他元素，此时将元素直接插入到桶中就可以了。当然，有时候会遇到被沾满的情况，
这也是不可避免的。这种现象被称为散列冲突（hash collision）。

在Java SE 8中，桶满时会从链表变为平衡二叉树。

在更改集中的元素时要格外小心。如果元素的散列码发生了改变，元素在数据结构中的位置也会发生变化。


### 树集

TreeSet类与散列集十分类似，不过，它比散列集有所改进。树集是一个有序集合（sorted collection）。可以
以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动按照排序后的顺序呈现。例如，假设插入3个字符串，
然后访问添加的所有元素。
```
SortedSet<String> sorter = new TreeSet<>(); // TreeSet implements SortedSet
sorter.add("Bob");
sorter.add("Amy");
sorter.add("Carl");

for (String s : sorter) System.println(s);
```
这时，每个值将按照顺序打印出来：Amy Bob Carl。排序是用树结构完成的（当前实现的是红黑树 red-black-tree）。
每次将一个元素添加到树中，都被放置在正确的排序位置上。因此，迭代器总是以排好序的顺序访问每个元素。

将一个元素添加到树中要比添加到散列表中慢，但是，与检查数组或链表中的重复元素相比还是快很多。
如果树中包含n个元素，查找新元素的正确位置平均需要log2n次比较。例如，如果一个棵树包含了1000个元素，添加一个
新元素大约需要比较10次。

要使用树集，必须能够比较元素。这些元素必须实现Comparable接口，或者构造集时必须提供一个Comparator。


### 队列与双端队列

前面已经讨论过，队列可以让人们有效地在尾部添加一个元素，在头部删除一个元素。有两个端头的队列，
即双端队列，可以让人们有效地在头部和尾部同时添加或删除元素。不支持在队列中间添加元素。
在Java SE 6中引入了Deque接口，并由ArrayDeque和LinkedList类实现。这两个类都提供了双端队列，
而且在必要时可以增加队列的长度。

### 优先级队列

优先级队列（priotity queue）中的元素可以按照任意的顺序插入，却总是按照排序的顺序进行检索。也就是说，
无论何时调用remove方法，总是会获得当前优先级队列中最小的元素。然而，优先级队列并没有对所有的元素
进行排序。如果用迭代的方式处理这些元素，并不需要对它们进行排序。优先级队列使用了一个优雅且高效的数据结构，
称为堆（heap）。堆是一个可以自我调整的二叉树，对树执行添加（add）和删除（remove）操作，可以让最小的元素
移动到根，而不必花费时间对元素进行排序。

于TreeSet一样，一个优先级队列既可以保存实现了Comparable接口的类对象，也可以保存在构造器中提供中
提供的Comparator对象。

使用优先级队列的经典示例是任务调度。每一个任务有一个优先级，任务以随机顺序添加到队列中。每当启动一个新的任务，
都将优先级最高的任务从队列中删除（由于习惯上将1设为最高优先级，所以会将最小的元素删除）。

与TreeSet中迭代不同，这里的迭代并不是按照元素的排序顺序访问的，而删除却总是删除掉剩余元素中优先级数最小的
那个元素。














