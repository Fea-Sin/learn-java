
## 对象与类

- 面向对象程序设计概述
- 使用预定义类
- 用户自定义类
- 静态域与静态方法
- 方法参数
- 对象构造
- 包
- 类路径
- 文档注释
- 类设计技巧

面向对象程序设计和面向过程程序设计在思维上存在着很大的差别，改变思维方式并不是一件很容易的事情。

### 面向对象程序设计概述

面向对象程序设计（简称OOP）是当今主流的程序设计范型，它已经取代了20世纪70年代的"结构化"过程化
程序设计开发技术，Java是完全面向对象的，必须熟悉OOP才能够编写Java程序。

面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。程序中的很多
对象来自标准库，还有一些是自定义的，究竟是自己构造对象，还是从外界购买对象完全取决于开发项目的
预算和时间。但是，从根本上说，只要对象能够满足要求，就不必关心其功能的具体实现过程。在OOP中，
不必关心对象的具体实现，只要能够满足用户的需求即可。

传统的结构化程序设计通过设计一系列的过程（即算法）来求解问题，一旦确定了这些过程，就要开始考虑存储
数据的方式。OOP将数据放在第一位，然后再考虑操作数据的算法。
对于一些规模较小的问题，将其分解为过程的开发方式比较理想，而面向对象更加适用于解决规模较大的问题。

#### 类

类是构造对象的模版或蓝图，我们可以将类想象成制作小甜饼的机器，将对象想象为小甜饼，由类构造（construct）
对象的过程称为创建类的实例（instance）。

正如前面所看到的，用Java编写的所有代码都位于某个类的内部，标准的Java库提供了几千个类，可以用于用户界面
设计、日期、日历和网络程序设计。尽管如此，还是需要在Java程序中创建一些自己的类，以便描述应用程序所对应
的问题域中的对象。

封装（encapsulation，有时称为数据隐藏）是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为
组合在一个包中，并对对象的使用者隐藏了数据的实现方式。对象中的数据称为实例域（instance field），操纵
数据的过程称为方法（method），对于每个特定的类实例（对象）都有一组特定的实例域值，这些值的集合就是这个
对象的当前状态（state），无论何时，只要向对象发送一个消息，它的状态就有可能发生改变。

实现封装的关键在于绝对不能让类中的方法直接地访问其它类的实例域，程序仅通过对象的方法与对象数据进行交互。
封装给对象赋予了"黑盒"特征，这是提高重用性和可靠性的关键，这意味着一个类可以全面地改变存储数据的方式，
只要仍旧使用同样的方法操作数据，其它对象就不会知道或介意所发生的变化。

OOP的另一个原则会让用户自定义Java类变得轻而易举，这就是，可以通过扩展一个类来建立另外一个新的类。
事实上，在Java中所有的类都源自于一个"神通广大的超类"，它就是Object。

在扩展一个已有的类时，这个扩展后的新类具有所有扩展的类的全部属性和方法，在新类中，只需提供适用于这个
新类的新方法和数据域就可以了。通过扩展一个类来建立另外一个类的过程称为继承（inheritance）。
 
#### 对象

想要使用OOP，一定要清楚对象的三个主要特性

- 对象的行为，可以对对象施加哪些操作，或可以对对象施加哪些方法
- 对象的状态，当施加那些方法时，对象如何响应
- 对象的标识，如何辨别具有相同行为与状态的不同对象

同一个类的所有对象实例，由于支持相同的行为而具有家族式的相似性，对象的行为是用可调用的方法定义的。
此外，每个对象都保存着描述当前特征的信息，这就是对象的状态，对象的状态可能会随着时间而发生改变，但
这种改变不会是自发的，对象状态的改变必须通过调用方法实现。
但是，对象的状态并不能完全描述一个对象，每个对象都有一个唯一的身份（identity）。例如，在一个订单
处理系统中，任何两个订单都存在着不同之处，即使所订购的货物完全相同也是如此。需要注意，作为一个类的
实例，每个对象的标识永远是不同的，状态常常也存在着差异。

对象的这些关键特性在彼此之间相互影响着。例如，对象的状态影响它的行为（如果一个订单"已送货"或"已付款"
就应该拒绝调用具有增删订单中条目的方法）。

#### 识别类

传统的过程化程序设计，必须从顶部的main函数开始编写程序，在面向对象程序设计时没有所谓的"顶部"对于
学习OOP的初学者来说常常会感觉无从下手，答案是，首先从设计类开始，然后再往每个类中添加方法。

识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。当然，所谓"找名词与动词"原则只是
一种经验，在创建类的时候，哪些名词和动词是重要的，完全取决于个人的开发经验。

#### 类之间的关系

在类之间，最常见的关系有

- 依赖（uses-a）
- 聚合（has-a）
- 继承（is-a）

依赖（dependence）即uses-a关系，是一种最明显的、最常见的关系。例如，Order(订单)类使用Account(账户)
类是因为Order对象需要访问Account对象查看信用状态。但是Item(商品)类不依赖于Account类，只是因为
Item对象于客户账户无关，因此，如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类。

应该尽可能地将相互依赖的类减至最少，如果类A不知道B的存在，它句不会关心B的任何改变（这就意味着B的改变
不会导致A产生bug），用软件工程的术语来说，就是让类之间的耦合堵最小。

聚合（aggregation）即has-a关系，是一种具体且易于理解的关系。例如，一个Order对象包含一些Item对象。
聚合关系意味着类A的对象包含类B的对象。

继承（inheritance）即is-a关系，是一种用于表示特殊于一般关系的。例如，RushOrder类由Order类继承
而来，在具有特殊性的RushOrder类中包含了一些用于优先处理的特殊方法，以及一个计算运费的不同方法，而其他
的方法，如添加商品、生成账单等都是从Order类继承来的。一般而言，如果类A扩展类B，类A不但包含从类B继承
的方法，还会拥有一些额外的功能。




