

## 使用预定义类

在Java中，没有类就无法做任何事情。我们前面曾经接触过几个类，然而，并不是所有的类都具有面向对象
特征。例如Math类，在程序中可以使用Math类的方法，如Math.random。并只需要知道方法名和参数，
而不必了解具体实现过程，这正是封装的关键所在，当然所有类都是这样。但遗憾的是，Math类只封装了
功能，它不要也不必隐藏数据，由于没有数据，因此也不必担心生成对象以及初始化实例域。更典型的类-Data类，
从中我呢可以看到如何构造对象，以及如何调用类的方法。

### 对象和对象变量

要想使用对象，就必须首先构造对象，并指定其初始状态，然后，对对象应用方法。
在Java程序设计语言中，使用构造器（constructor）构造新实例，构造器是一种特殊的方法，用来构造并初始化
对象。

构造器的名字应该与类名相同，因此Date类的构造器名为Date。想要构造一个Date对象，需要在构造器前面加上
new操作符`new Date()`，这个表达式构造了一个新对象，这个对象被初始化为当前日期和时间。如果需要的话，
可以将对象传递给一个方法
```
System.println(new Date());
```
或者，也可以将一个方法应用于刚刚创建的对象。Data类中有一个toString方法，这个方法将返回日期的字符串
描述。
```
String s = new Date().toString();
```
在这个例子中，构造的对象仅使用了一次，通常希望构造的对象可以多次使用，因此需要将对象存放在一个变量中
```
Date birthday = new Date();
```

在对象和对象变量之间存在着一个重要的区别。例如语句
```
Date deadline;  // deadline doesn't refer to any object
```
对象变量deadline，它可以引用Date类型对象，但是，一定要认识到，变量deadline不是一个对象，此时，不能将任何
Date方法应用于这个变量上。`s = deadline.toString();`将产生编译错误。必须首先初始化变量deadline，
这里有两个选择，可以用新构造的对象初始化这个变量：`deadline = new Date();`，也可以让这个变量引用
一个已经存在的对象`deadline = birthday;`。

一定要认识到，一个对象变量并没有实际包含了一个对象，而仅仅引用了一个对象。在Java中，任何对象变量的值都是
对存储在另一个地方的一个对象的引用。new操作符的返回值也是一个引用。
```
Date deadline = new Date();
```
上面语句，表达式new Date()构造了一个Date类型的对象，并且它的值是对新创建对象的引用，这个应用存储在
变量deadline中。
可以显式地将对象变量设置为null，表明这个对象变量目前没有引用任何对象。
```
deadline = null;
```
如果将一个方法应用于一个值为null的对象上，那么就会产生**运行时错误**。

很多人错误地认为Java对象变量于C++的应用类似，然而，在C++中没有空引用，并且引用不能被赋值。可以将Java
的对象变量看作C++的对象指针，`Date birthday // Java`实际上等同于，`Date* birthday // C++`，
一旦理解了这一点，一切问题就迎刃而解了。当然，一个Date*指针只能通过调用new进行初始化。

如果把一个变量的值赋给另一个变量，两个变量就指向同一个日期，即它们是同一个对象的指针。在Java中的null
引用对应C++中的NULL指针。
所有的Java对象都存储在堆中，当一个对象包含另一个对象变量时，这个变量依然包含着指向另一个堆对象的指针。

在C++中，指针十分令人头疼，并常常导致程序错误，稍不小心就会创建一个错误的指针，或者造成内存溢出。
在Java语言中，这些问题都不复存在，如果使用了一个没有初始化的指针，运行系统会产生一个运行时错误，而不是
生成一个随机结果。同时，不必担心内存管理问题，垃圾收集器将会处理相关的事宜。


### Java类库中的LocalDate类

在前面的例子中，已经使用了Java标准类库中的Date类。Date类的实例有一个状态，即特定的时间点。
时间是用距离一个固定时间点的毫秒数表示的，这个点就是所谓的纪元（epoch），它是UTC时间
1970年1月1日00:00:00。
但是，Date类所提供的日期处理并没有太大的用途。类库设计者决定将保存时间与给时间点命名分开，所以标准
Java类库分别包含了两个类，一个用来表示时间点的Date类，另一个是用来表示大家熟悉的日历表示法的LocalDate类。
将时间与日历分开是一种很好的面向对象设计，通常最好使用不同的类表示不同的概念。

不要使用构造器来构造LocalDate类的对象，实际上，应当使用静态工厂方法（factory method）代表你调用
构造器。
```
LocalDate.now()
```
上面会构造一个新的对象，表示构造这个对象时的日期。可以提供年、月、日来构造对应一个特定日期的对象
```
LocalDate newYearsEve = LocalDate.of(1999, 12, 31)
```
有时可能某个日期是计算得到的，plusDays方法会得到一个新的LocalDate，这个新日期对象则是距当前对象
指定天数的一个新日期
```
LocalDate aThousandDaysLater = newYearsEve.plusDays(1000);
year = aThousandDaysLater.getYear(); // 2002
```
LocalDate类封装了实例域来维护所设置的日期。

这个调用之后newYearsEve会有什么变化？它会改为1000天之后的日期吗？事实上，并没有。plusDays方法
会生成一个新的LocalDate对象，然后把这个新对象赋给aThousandDaysLater变量。原来的对象不做任何改动。

[实例](CalendarTest/CalendarTest.java)

可以看到，利用LocalDate类可以编写一个日期程序，能处理星期几以及各月天数不同等复杂问题。你并不需要知道
LocalDate类如何计算月和星期几，只需要使用这个类的接口，如plusDays和getDayOfWeek等方法。
这个示例程序的重点是向你展示如何使用一个类的接口来完成相当复杂的任务，而无需了解实现细节。











